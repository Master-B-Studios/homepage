<!DOCTYPE html>
<html>
  <head>
  <title>PS Cheat-Creator</title>
  <meta charset="utf-8"></meta>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"></meta>
  <link rel="icon" type="image/x-icon" href="../../images/MB_Icon_01.png"></link>
  <link rel="stylesheet" href="../../assets/css/main.css"></link>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@200;300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    article {font-family: 'JetBrains Mono', monospace;font-weight: 200;letter-spacing: 1px;}
    .table_container {border: 1px solid #444444;border-collapse: separate;border-spacing: 6px;border-collapse: separate;table-layout: fixed;font-size: 0.8em;}
    .table_td_var {width: auto;height: 1.5em;padding: 0.5em;}
    .table_td_025 {width: 25%;height: 1.5em;padding: 0.5em;}
    .table_td_030 {width: 30%;height: 1.5em;padding: 0.5em;}
    .table_td_050 {width: 50%;height: 1.5em;padding: 0.5em;}
    .table_td_070 {width: 70%;height: 1.5em;padding: 0.5em;}
    .table_td_075 {width: 75%;height: 1.5em;padding: 0.5em;}
    .table_td_100 {width: 75%;height: 1.5em;padding: 0.5em;}

    .text_left {text-align: left;margin: auto;}
    .text_right {text-align: right;margin: auto;}
    .text_center {text-align: center;margin: auto;}

    .editable {cursor: pointer;background-color: #080808;}
    .editable:hover {color: #00aa44;background-color: #222222;transition: all 1.5s;}

    .icon_td_025 {width: 25%;padding: 0;cursor: pointer;vertical-align: middle;}
    .icon_wrapper {width: 100%;height: 100%;display: flex;justify-content: center;align-items: center;}
    .icon {max-height: 1.5em;width: auto;display: block;}
    .icon_td_025:hover {background-color: #440000;transition: all 1.5s;}
  </style>
</head>
<body onload="window.location.href = '#playstation';localStorage.getItem('page');" class="is-preload">
  <div id="wrapper">
    
    <nav id="nav">
      <a href="../../index.html"><img class="mb_icon" src="../../images/MB_Icon_02.png"></img><span>Home</span></a>
      <a href="../../Web-Tools/web-tools.html"><img class="mb_icon" src="../../images/Web_Icon_01.png"></img><span>Web-Tools</span></a>
      <a href="../../Local-Tools/local-tools.html"><img class="mb_icon" src="../../images/CMD_Icon_01.png"></img><span>Local-Tools</span></a>
      <a href="../../Games/games.html"><img class="mb_icon" src="../../images/Games_Icon_01.png"></img><span>Games</span></a>
      <a href="#playstation"><img class="mb_icon" src="icon_01.png"></img><span>Cheats</span></a>
      
    </nav>
    
    <div id="main">
      <article id="playstation" class="panel">
        <div class="tr_flipper_gap"></div>
        <header>Import: .shn .json .mc4 (decrypted & encrypted)<br>Export: .shn</header>
        
        <section>
          <table class="table_container" style="cursor: default;">
            <tr>
              <td class="table_td_025 text_right">Name Des Spiels:</td>
              <td id="game_title" class="table_td_075 text_center editable" colspan="3" contenteditable="true"></td>
            </tr>
            <tr>
              <td class="table_td_025 text_right">ID: (CUSA12345)</td>
              <td id="game_id" class="table_td_025 text_center editable" contenteditable="true"></td>
              <td class="table_td_025 text_right">Version: (01.00)</td>
              <td id="game_version" class="table_td_025 text_center editable" contenteditable="true"></td>
            </tr>
            <tr>
              <td class="table_td_025 text_right">Genre:</td>
              <td id="game_genre" class="table_td_025 text_center editable" contenteditable="true">Master Studios</td>
              <td class="table_td_025 text_right">Prozess:</td>
              <td id="game_process" class="table_td_025 text_center editable" contenteditable="true">eboot.bin</td>
            </tr>
          </table>
        </section>

        <section id="cheat_section"></section>

        <section id="nav_section">
          <table class="table_container" style="cursor: default;">
            <tr>
              <td class="table_td_030 text_center editable" onclick="uploadTrainer();">File Hochladen</td>
              <input type="file" id="trainerFileInput" accept=".shn,.xml,.json,.mc4" style="display:none" />
              <td class="table_td_030 text_center editable" onclick="exportTrainer();">File Herunterladen</td>
              <td class="table_td_030 text_center editable" onclick="add_cheat();">Cheat Hinzufügen</td>
            </tr>
          </table>
        </section>

        <div class="tr_flipper_gap"></div>
      </article>
    </div>
    
    <div id="footer"><ul class="copyright"><li>&copy; Master B</li></ul></div>

  </div>
</body>

<script src="../../assets/js/jquery.min.js"></script>
<script src="../../assets/js/browser.min.js"></script>
<script src="../../assets/js/breakpoints.min.js"></script>
<script src="../../assets/js/util.js"></script>
<script src="../../assets/js/main.js"></script>

<script>
let cheatCounter = 0;
const container = document.getElementById("cheat_section");

function formatHexInput(value) {
  let cleaned = value.replace(/[^0-9a-fA-F]/g, "");
  cleaned = cleaned.toUpperCase();
  const pairs = cleaned.match(/.{1,2}/g);
  return pairs ? pairs.join("-") : "";
}

document.addEventListener("input", function (e) {
  if (!(e.target.classList.contains("hex_on") || e.target.classList.contains("hex_off"))) return;
  const element = e.target;
  const formatted = formatHexInput(element.textContent);
  element.textContent = formatted;
  const range = document.createRange();
  range.selectNodeContents(element);
  range.collapse(false);
  const selection = window.getSelection();
  selection.removeAllRanges();
  selection.addRange(range);
});

document.addEventListener("paste", function (e) {
  if (!e.target.matches('[contenteditable="true"]')) return;
  e.preventDefault();
  let text = e.clipboardData.getData("text/plain");
  if (e.target.classList.contains("hex_on") || e.target.classList.contains("hex_off")) {text = formatHexInput(text);}
  const selection = window.getSelection();
  if (!selection.rangeCount) return;
  selection.deleteFromDocument();
  selection.getRangeAt(0).insertNode(document.createTextNode(text));
  selection.collapseToEnd();
});

function add_cheat() {
  const cheatCount = document.querySelectorAll("#cheat_section > section").length + 1;
  const cheatId = "c_" + Date.now();
  const section = document.createElement("section");
  section.dataset.cheatId = cheatId;
  section.innerHTML = `
    <table id="table_${cheatId}" class="table_container">
      <tr>
        <td class="table_td_025"></td>
        <td class="table_td_050 text_center" colspan="2">Cheat ${cheatCount}</td>
        <td class="icon_td_025 removeCheat">
          <div class="icon_wrapper">
            <img class="icon" src="../../images/Trash_01.png">
          </div>
        </td>
      </tr>
      <tr>
        <td class="table_td_025 text_right">Beschreibung:</td>
        <td id="desc_${cheatCount}" class="table_td_075 editable" contenteditable="true" colspan="3"></td>
      </tr>
      <tr class="tr_flipper_gap"></tr>
    </table>
    <table class="table_container">
      <tr>
        <td class="table_td_100 text_center editable addOffset">Offset Hinzufügen</td>
      </tr>
    </table>
  `;
  document.getElementById("cheat_section").appendChild(section);
  section.querySelector(".addOffset").addEventListener("click", () => add_offset(cheatId));
  section.querySelector(".removeCheat").addEventListener("click", () => {section.remove();renumberCheats();});
  return section;
}

function add_offset(cheatId, section = null) {
  const table = section ? section.querySelector("table") : document.getElementById("table_" + cheatId);
  if (!table) return null;
  const offsetCount = table.querySelectorAll(".offset-block").length + 1;
  const wrapper = document.createElement("tbody");
  wrapper.classList.add("offset-block");
  wrapper.innerHTML = `
    <tr>
      <td class="table_td_025 text_right">Offset ${offsetCount}</td>
      <td class="table_td_025 editable hex_offset" contenteditable="true" colspan="2"></td>
      <td class="icon_td_025 text_center removeOffset">
        <div class="icon_wrapper"><img class="icon" src="../../images/Trash_01.png"></div>
      </td>
    </tr>
    <tr>
      <td class="table_td_025 text_right">An:</td>
      <td class="table_td_025 editable hex_on" contenteditable="true" colspan="3"></td>
    </tr>
    <tr>
      <td class="table_td_025 text_right">Aus:</td>
      <td class="table_td_025 editable hex_off" contenteditable="true" colspan="3"></td>
    </tr>
    <tr>
      <td class="table_td_025 text_right">Section:</td>
      <td class="table_td_025 editable valsection" contenteditable="true" colspan="3">0</td>
    </tr>
    <tr class="tr_flipper_gap"><td></td><td></td><td></td><td></td></tr>
  `;
  table.appendChild(wrapper);
  wrapper.querySelector(".removeOffset").addEventListener("click", () => {
    wrapper.remove();
    const sec = table.closest("section");
    renumberOffsets(sec);
  });
  return wrapper;
}

function renumberCheats() {
  const sections = document.querySelectorAll("#cheat_section > section");
  sections.forEach((section, index) => {
    const titleCell = section.querySelector("td[colspan='2']");
    if (titleCell) {titleCell.textContent = "Cheat " + (index + 1);}
  });
}

function renumberOffsets(section) {
  const offsetBlocks = section.querySelectorAll(".offset-block");
  offsetBlocks.forEach((block, index) => {
    const addressLabel = block.querySelector("tr:first-child td:first-child");
    if (addressLabel) {addressLabel.textContent = "Offset " + (index + 1) + ":";}
  });
}

function generateXML(title, gaId, version, genre, process, modder) {
  const sections = document.querySelectorAll("#cheat_section > section");
  let cheatsXML = "";
  sections.forEach(section => {
    const cheatTitle = section.querySelector(".table_td_075.editable")?.textContent.trim() || "";
    const offsetBlocks = section.querySelectorAll(".offset-block");
    let cheatlinesXML = "";

    offsetBlocks.forEach(block => {
      const offset = block.querySelector(".hex_offset")?.textContent.trim() || "";
      const valueOn = block.querySelector(".hex_on")?.textContent.trim() || "";
      const valueOff = block.querySelector(".hex_off")?.textContent.trim() || "";
      const valueSection = block.querySelector(".valsection")?.textContent.trim() || "";
      cheatlinesXML += `
    <Cheatline>
      <Offset>${offset}</Offset>
      <Section>${valueSection}</Section>
      <ValueOn>${valueOn}</ValueOn>
      <ValueOff>${valueOff}</ValueOff>
    </Cheatline>`;
    });

    cheatsXML += `
  <Cheat Text="${cheatTitle}">${cheatlinesXML}
  </Cheat>`;
  });

  return `<?xml version="1.0" encoding="utf-16"?>
<Trainer xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" Game="${title}" Moder="${modder}" Cusa="${gaId}" Version="${version}" Process="${process}">
  <Genres Name="${genre}"/>
  <Items/>${cheatsXML}
</Trainer>`;
}

function downloadSHNFile(filename, content) {
  const encoder = new TextEncoder("utf-16le");
  const encoded = encoder.encode(content);
  const blob = new Blob([encoded], { type: "text/xml;charset=utf-16;" });
  const link = document.createElement("a");
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

function exportTrainer() {
  const gameTitle = document.getElementById("game_title");
  const gameId = document.getElementById("game_id");
  const gameVersion = document.getElementById("game_version");
  const gameGenre = document.getElementById("game_genre");
  const gameProcess = document.getElementById("game_process");
  const modder = "Master Studios";

  if (!gameTitle || !gameId || !gameVersion || !gameGenre || !gameProcess) {alert("Ein Pflichtfeld fehlt!");return;}

  const title = gameTitle.textContent.trim();
  const gaId = gameId.textContent.trim().toUpperCase();
  const version = gameVersion.textContent.trim();
  const genre = gameGenre.textContent.trim();
  const process = gameProcess.textContent.trim();

  if (!/^[A-Z]{4}[0-9]{5}$/.test(gaId)) {alert("CUSA ungültig! (z.B. CUSA12345)");return;}
  if (!/^\d{2}\.\d{2}$/.test(version)) {alert("Version ungültig! (z.B. 01.04)");return;}

  const xmlContent = generateXML(title, gaId, version, genre, process, modder);
  const filename = `${gaId}_${version}.shn`;
  downloadSHNFile(filename, xmlContent);
}

async function uploadTrainer() {
  const input = document.getElementById("trainerFileInput");
  input.value = "";
  input.click();

  input.onchange = async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const ext = file.name.toLowerCase();
    const text = await file.text();

    if (ext.endsWith(".json")) {parseJSONTrainer(text);return;}
    if (ext.endsWith(".mc4")) {
      let xmlText;
      const decodedEntities = decodeHTMLEntities(text.trim());
      if (decodedEntities.startsWith("&lt;") || decodedEntities.startsWith("<?xml")) {
        xmlText = cleanMC4XML(decodedEntities);
      }
      else {
        const decrypted = await decryptMC4(text);
        if (!decrypted) return;
        xmlText = cleanMC4XML(decrypted);
      }
      parseMC4Trainer(xmlText);
      return;
    }

    parseXMLTrainer(text);
  };
}

function parseJSONTrainer(jsonText) {
  let data;
  try {data = JSON.parse(jsonText);}
  catch (e) {alert("Ungültige JSON-Datei!");return;}
  if (!data || !data.mods) {alert("Ungültiges JSON-Format!");return;}

  document.getElementById("game_title").textContent = data.name || "";
  document.getElementById("game_id").textContent = (data.id || "").toUpperCase();
  document.getElementById("game_version").textContent = data.version || "";
  document.getElementById("game_process").textContent = data.process || "";
  document.getElementById("game_genre").textContent = "Unknown";

  const cheatSectionContainer = document.getElementById("cheat_section");
  cheatSectionContainer.innerHTML = "";

  data.mods.forEach((mod, index) => {
    const cheatId = add_cheat();
    const section = cheatSectionContainer.querySelectorAll("section")[index];
    const descTD = section.querySelector(".table_td_075.editable");
    if (descTD) descTD.textContent = mod.name || "";
    if (!mod.memory || !Array.isArray(mod.memory)) return;

    mod.memory.forEach((mem, i) => {
      const block = add_offset(cheatId, section);
      if (!block) return;
      const offset = (mem.offset || "").toUpperCase();
      const valueSection = (mem.valueSection || "0");
      const valueOn = formatHexInput(mem.on || "");
      const valueOff = formatHexInput(mem.off || "");
      block.querySelector(".hex_offset").textContent = offset;
      block.querySelector(".valsection").textContent = valueSection;
      block.querySelector(".hex_on").textContent = valueOn;
      block.querySelector(".hex_off").textContent = valueOff;
    });

  });
  renumberCheats();
}

function parseXMLTrainer(xmlText) {
  let parser = new DOMParser();
  let xml;
  try {xml = parser.parseFromString(xmlText, "application/xml");}
  catch(e) {alert("Ungültige XML-Datei!");return;}
  const trainer = xml.querySelector("Trainer");
  if (!trainer) return alert("Ungültiges SHN-Format!");

  document.getElementById("game_title").textContent = trainer.getAttribute("Game") || "";
  document.getElementById("game_id").textContent = trainer.getAttribute("Cusa") || "";
  document.getElementById("game_version").textContent = trainer.getAttribute("Version") || "";
  document.getElementById("game_process").textContent = trainer.getAttribute("Process") || "";
  document.getElementById("game_genre").textContent = trainer.getAttribute("Moder") || "";

  const cheatSectionContainer = document.getElementById("cheat_section");
  cheatSectionContainer.innerHTML = "";
  const cheats = trainer.querySelectorAll("Cheat");

  for (let i = 0; i < cheats.length; i++) {
    const cheat = cheats[i];
    const cheatText = cheat.getAttribute("Text") || "";
    const cheatId = add_cheat();
    const section = cheatSectionContainer.querySelectorAll("section")[i];
    const descTD = section.querySelector(".table_td_075.editable");
    if (descTD) descTD.textContent = cheatText;
    const cheatlines = cheat.querySelectorAll("Cheatline");

    for (let j = 0; j < cheatlines.length; j++) {
      const line = cheatlines[j];
      const block = add_offset(cheatId, section);
      if (!block) continue;
      const offset = (line.querySelector("Offset")?.textContent || "").toUpperCase();
      const valueSection = (line.querySelector("Section")?.textContent || "");
      const valueOn = formatHexInput(line.querySelector("ValueOn")?.textContent || "");
      const valueOff = formatHexInput(line.querySelector("ValueOff")?.textContent || "");
      block.querySelector(".hex_offset").textContent = offset;
      block.querySelector(".valsection").textContent = valueSection;
      block.querySelector(".hex_on").textContent = valueOn;
      block.querySelector(".hex_off").textContent = valueOff;
    }
  }
  renumberCheats();
}

function parseMC4Trainer(xmlText) {
  xmlText = decodeHTMLEntities(xmlText);
  let parser = new DOMParser();
  let xml;
  try {xml = parser.parseFromString(xmlText, "application/xml");}
  catch (e) {alert("Ungültige MC4 XML-Datei!");return;}
  const trainer = xml.querySelector("Trainer");
  if (!trainer) {alert("Trainer-Node nicht gefunden!");return;}
  document.getElementById("game_title").textContent = trainer.getAttribute("Game") || "";
  document.getElementById("game_id").textContent = trainer.getAttribute("Cusa") || "";
  document.getElementById("game_version").textContent = trainer.getAttribute("Version") || "";
  document.getElementById("game_process").textContent = trainer.getAttribute("Process") || "";
  const genres = [...trainer.querySelectorAll("Genres")]
    .map(g => g.getAttribute("Name"))
    .join(", ");
  document.getElementById("game_genre").textContent = genres;
  const cheatSectionContainer = document.getElementById("cheat_section");
  cheatSectionContainer.innerHTML = "";
  const cheats = trainer.querySelectorAll("Cheat");

  cheats.forEach((cheat, index) => {
    const cheatId = add_cheat();
    const section = cheatSectionContainer.querySelectorAll("section")[index];
    const descTD = section.querySelector(".table_td_075.editable");
    if (descTD) descTD.textContent = cheat.getAttribute("Text") || "";
    const lines = cheat.querySelectorAll("Cheatline");

    lines.forEach(line => {
      const block = add_offset(cheatId, section);
      if (!block) return;
      const offset = line.querySelector("Offset")?.textContent.trim().toUpperCase() || "";
      const valueSection = line.querySelector("Section")?.textContent.replace(/-/g, "").trim() || "";
      const valueOn = line.querySelector("ValueOn")?.textContent.replace(/-/g, "").trim() || "";
      const valueOff = line.querySelector("ValueOff")?.textContent.replace(/-/g, "").trim() || "";
      block.querySelector(".hex_offset").textContent = offset;
      block.querySelector(".valsection").textContent = valueSection;
      block.querySelector(".hex_on").textContent = formatHexInput(valueOn);
      block.querySelector(".hex_off").textContent = formatHexInput(valueOff);
    });
  });

  renumberCheats();
}

function decodeHTMLEntities(text) {
  const textarea = document.createElement("textarea");
  textarea.innerHTML = text;
  return textarea.value;
}

function cleanMC4XML(xmlText) {
  const textarea = document.createElement("textarea");
  textarea.innerHTML = xmlText;
  xmlText = textarea.value;
  xmlText = xmlText.replace(/[^\x09\x0A\x0D\x20-\xFF]/g, "");
  xmlText = xmlText.replace(/\\"/g, '"');
  return xmlText;
}

async function decryptMC4(base64Text) {
  try {
    const binary = Uint8Array.from(atob(base64Text.trim()), c => c.charCodeAt(0));
    const keyStr = "304c6528f659c766110239a51cl5dd9c";
    const ivStr  = "u@}kzW2u[u(8DWar";
    const enc = new TextEncoder();
    const keyBytes = enc.encode(keyStr);
    const ivBytes  = enc.encode(ivStr);

    const cryptoKey = await crypto.subtle.importKey(
      "raw",
      keyBytes,
      { name: "AES-CBC" },
      false,
      ["decrypt"]
    );

    const decrypted = await crypto.subtle.decrypt(
      { name: "AES-CBC", iv: ivBytes },
      cryptoKey,
      binary
    );

    const decoder = new TextDecoder("utf-16");
    return cleanMC4XML(decoder.decode(decrypted));

  }
  catch (e) {
    alert("MC4 Decrypt fehlgeschlagen!");
    console.error(e);
    return null;
  }
}
</script>